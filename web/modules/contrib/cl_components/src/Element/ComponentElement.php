<?php

namespace Drupal\cl_components\Element;

use Drupal\Component\Utility\Xss;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Render\Element\RenderElement;

/**
 * Provides a Storybook component render element.
 *
 * Properties:
 * - #component: The machine name of the component.
 * - #variant: (optional) The variant to be used for the component.
 *
 * Usage Example:
 *
 * @code
 * $build['component'] = array(
 *   '#type' => 'cl_component',
 *   '#component' => 'button',
 *   '#variant' => 'secondary',
 * );
 * @endcode
 *
 * @see \Drupal\Core\Render\Element\Textarea
 *
 * @RenderElement("cl_component")
 */
class ComponentElement extends RenderElement {

  /**
   * Expands a cl_component into an inline template with an attachment.
   *
   * @param array $element
   *   The element to process. See main class documentation for properties.
   *
   * @return array
   *   The form element.
   *
   * @throws \Drupal\cl_components\Exception\ComponentNotFoundException
   */
  public static function preRenderComponent(array $element): array {
    $variant = $element['#variant'] ?? '';
    $context_alter_callback = $element['#context_alter_callback'] ?? NULL;
    $blocks_alter_callback = $element['#blocks_alter_callback'] ?? NULL;
    $manager = cl_components_manager();
    $id = $element['#component'];
    $component = str_contains($id, ':')
      ? $manager->createInstance($id)
      : $manager->find($id);
    $context = $element['#context'] ?? [];
    $bubbleable_metadata = new BubbleableMetadata();
    $twig_blocks = $element['#twig_blocks'] ?? [];
    $trusted_blocks = $element['#trusted_blocks'] ?? FALSE;
    $inline_template = static::generateComponentTemplate(
      $id,
      $variant,
      $twig_blocks,
      $context,
      $context_alter_callback,
      $blocks_alter_callback,
      $bubbleable_metadata,
      $trusted_blocks,
    );
    $element['inline-template'] = [
      '#type' => 'inline_template',
      '#template' => $inline_template,
      '#context' => $context,
    ];
    $bubbleable_metadata->applyTo($element['inline-template']);
    return $element;
  }

  /**
   * Generates the template to render the component.
   *
   * @param string $id
   *   The component id.
   * @param mixed $variant
   *   The variant.
   * @param array $twig_blocks
   *   The contents of any potential embed blocks.
   * @param array $context
   *   The context data.
   * @param callable|null $context_alter_callback
   *   The potential callable for altering context.
   * @param \Drupal\Core\Cache\CacheableMetadata $bubbleable_metadata
   *   The cacheable metadata.
   * @param bool $trusted_blocks
   *   Set to TRUE to render the twig blocks verbatim instead of filtering them.
   *
   * @return string
   *   The template.
   */
  private static function generateComponentTemplate(
    string $id,
    string $variant,
    array $twig_blocks,
    array $context,
    mixed $context_alter_callback,
    mixed $blocks_alter_callback,
    CacheableMetadata $bubbleable_metadata,
    bool $trusted_blocks = FALSE,
  ): string {
    $embed_id = $variant ? $id . '--' . $variant : $id;
    $template = '{# This template was dynamically generated by cl_block #}' . PHP_EOL;
    // If there is a context alter callback, execute it here.
    if (is_callable($context_alter_callback)) {
      $context = call_user_func($context_alter_callback, $context, $bubbleable_metadata);
    }
    try {
      $serialized_context = json_encode($context, JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    }
    catch (\JsonException $e) {
      $serialized_context = '';
    }
    $template .= empty($context)
      ? sprintf('{%% embed \'%s\' %%}', $embed_id)
      : sprintf('{%% embed \'%s\' with %s %%}', $embed_id, $serialized_context);
    $template .= PHP_EOL;
    foreach ($twig_blocks as $block_name => $block_value) {
      $bl_val = is_callable($blocks_alter_callback)
        ? call_user_func($blocks_alter_callback, $block_value, $bubbleable_metadata)
        : $block_value;
      $block_build = $trusted_blocks
        ? ['#markup' => Xss::filterAdmin($bl_val)]
        : [
          '#type' => 'processed_text',
          '#text' => $bl_val,
          '#format' => is_array($block_value) ? $block_value['format'] : NULL,
        ];
      try {
        $value = \Drupal::service('renderer')->render($block_build);
      }
      catch (\Exception $e) {
        $value = $bl_val;
      }
      // Save the collected attachments before we do the stringification.
      $twig_block_metadata = BubbleableMetadata::createFromRenderArray($block_build);
      $bubbleable_metadata = $bubbleable_metadata->merge($twig_block_metadata);
      $template .= "  {% block $block_name %}" . PHP_EOL
        . "    $value" . PHP_EOL
        . "  {% endblock %}" . PHP_EOL;
    }
    $template .= '{% endembed %}' . PHP_EOL;
    return $template;
  }

  /**
   * {@inheritdoc}
   */
  public function getInfo(): array {
    $class = static::class;
    return [
      '#pre_render' => [
        [$class, 'preRenderComponent'],
      ],
      '#component' => '',
      '#variant' => '',
      '#context' => [],
    ];
  }

}
